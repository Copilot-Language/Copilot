TODOs

* Modify atom so that it refuses names that produce invalid C code. See
   checkname in Language.Atom.Elaboration.hs (still probably bugged) Also see
   normalizeVar in Language.Copilot.Core.hs.

 * Add arrays to the language(?)

 * Do MC/DC coverage testing(?)
   * Use the open-source Certification thing?

 * AIG-based equivalence checking.

 * Add math.h functions to Language.hs.

 * Move all the error-checking to one file, instead of "error ..." spread all
   over.

 * Better error handling/error message for bad options/parameters for interface
   functions.  Perhaps use hsTidy?  <http://hackage.haskell.org/package/hstidy>

 * Use para <http://hackage.haskell.org/package/para> for pretty-formatting
   error msgs from Analyzer.hs as well as Help.hs.
 
 * Go through using hlint suggestions.

 * Add to Help.hs documentation on using the setClock function to use the HW
   clock.

 * Fix splint warnings on generated C code 

 * Libs/Indexes return a parameterized type rather than Int16

 * Display external vars when interpreting

 * send lets you send stream values on ports at some phase.  Make sure that the
   stream semantics are preserved by ensuring you don't send at in appropriate
   times.

 * Allow for sampling functions; i.e., you get the return value of the
   function.  So you don't have to set up extra C vars to get the function
   values.

 * Right now, you can't have a spec with 3 == a or 3 < a, where a is a var of
   the right type, since the constant '3' isn't lifted automatically.  For
   something like 3 + a, it is, because Spec a can be an instance of Num (see
   Core.hs).  This is because operators like + are of type a -> a -> a.  But
   Spec can't be an instance of Ord, since < returns a Bool, not a Spec Bool.
   Furthermore, classes won't work, since you want something like this:

   class MyEq a b where
     (==) :: a -> b -> Spec Bool
     (/=) :: a -> b -> Spec Bool

   instance (Streamable a, A.EqE a) => MyEq (Spec a) (Spec a) where
     (==) = F2 (P.==) (A.==.)
     (/=) = F2 (P./=) (A./=.)

   instance (Streamable a, A.EqE a, P.Eq a) => MyEq a a where
     (==) x y = F2 (P.==) (A.==.) (Const x) (Const y)
     (/=) x y = F2 (P./=) (A./=.) (Const x) (Const y)

   but this leads to overlapping instances.  I think this problem needs to be
   solved with template Haskell(?).

 * Make triggers part of the language?
